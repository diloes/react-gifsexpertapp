{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValor","setInputValor","onSubmit","e","preventDefault","trim","length","catgrs","type","value","onChange","target","onClick","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","key","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"oMAGaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAE1B,EAAoCC,mBAAS,4BAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KA6BA,OACI,sBAAMC,SAtBW,SAAAC,GAEjBA,EAAEC,iBAEEJ,EAAWK,OAAOC,OAAS,IAE3BR,GAAe,SAAAS,GAAM,OAAMP,GAAN,mBAAsBO,OAC3CN,EAAc,MAelB,SACI,uBACIO,KAAK,OACLC,MAAQT,EACRU,SAhCiB,SAAAP,GAEzBF,EAAcE,EAAEQ,OAAOF,QA+BfG,QAdO,SAAAT,GAEG,6BAAfH,GACCC,EAAc,U,8BC3BbY,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEbC,EAFa,iDAEoCC,UAAWH,GAF/C,+DAGAI,MAAOF,GAHP,cAGbG,EAHa,gBAIIA,EAAKC,OAJT,uBAIXC,EAJW,EAIXA,KAGFC,EAAOD,EAAKE,KAAK,SAAAC,GAAQ,IAAD,EAG1B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAbvB,kBAkBZM,GAlBY,4CAAH,sDCiBPO,EAAc,SAAC,GAAuB,EAArBJ,GAAsB,IAAlBC,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAIrC,OACI,sBAAKc,UAAU,yCAAf,UACI,qBAAKC,IAAMf,EAAMgB,IAAMN,IACvB,kCAAMA,EAAN,WCrBCO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAGtB,ECJwB,SAAEA,GAE1B,MAA0Bf,mBAAS,CAE/BsB,KAAM,GACNa,SAAS,IAHb,mBAAOC,EAAP,KAAcC,EAAd,KA6BA,OAtBAC,qBAAW,WAEPxB,EAASC,GACJwB,MAAM,SAAAC,GAGHH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAItB,CAACpB,IAUGqB,ED3B0BK,CAAc1B,GAAlCa,EAAb,EAAQN,KAAaa,EAArB,EAAqBA,QAqCrB,OAEI,qCACI,qBAAIJ,UAAU,yCAAd,cAA0DhB,EAA1D,OAIEoB,GAAW,mBAAGJ,UAAU,wCAAb,yBAEb,qBAAKA,UAAU,YAAf,SAGQH,EAAOJ,KAAK,SAAAC,GACR,OACI,wBAAC,EAAD,2BAAiBA,GAAjB,IAAsBiB,IAAMjB,EAAIC,eEvD/CiB,EAAe,WAExB,MAAoC3C,mBAAS,CAAC,qBAA9C,mBAAO4C,EAAP,KAAmB7C,EAAnB,KAUA,OACI,qCACI,8CACA,cAAC,EAAD,CAAaA,cAAgBA,IAC7B,uBAEA,6BAEQ6C,EAAWpB,KAAK,SAAET,GAEd,OACI,aADe,CACd,EAAD,CAEAA,SAAWA,GADLA,Y,MCpBlC8B,IAASC,OACL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.910ad9ca.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\n\nexport const AddCategory = ({ setCategories }) => {\n\n    const [inputValor, setInputValor] = useState('Introduce tu búsqueda');\n\n    const manipularInputChange = e => {\n\n        setInputValor(e.target.value)\n\n    }\n\n    const enviarSubmit = e => {\n        \n        e.preventDefault(); \n\n        if( inputValor.trim().length > 2 ) {\n\n            setCategories( catgrs => [ inputValor , ...catgrs ]);\n            setInputValor('');\n        }\n\n    }\n\n    //Esto es un añadido personal by diloes\n    const clickVacio = e => {\n\n        if(inputValor === 'Introduce tu búsqueda') { \n            setInputValor('');\n        }\n        \n    }\n\n    return (\n        <form onSubmit={ enviarSubmit }>\n            <input \n                type=\"text\"\n                value={ inputValor }\n                onChange={ manipularInputChange }\n                onClick={ clickVacio }\n            />\n        </form>\n    )\n}\n\nAddCategory.propTypes = {\n\n    setCategories: PropTypes.func.isRequired\n\n}\n\n/*\n\nNOTAS: \n - Este componente AddCategory sirve para añadir a través de un input una nueva categoría a la lista(array)\n\n - El atributo onChange es: cuando cambie algo en el imput vas a hacer lo que está en las llaves\n\n  - No es necesario tener siempre el fragment <> </> o <fragment></fragment> ya que lo único que nos pide react es que todo esté\n envuelto en una etiqueta, un padre. En este caso usaremos <form></form>\n \n - e.preventDefault(); es para prevenir el comportamiento por defecto del formulario, que es recagar la página \n cuando damos a enter. Si lo ponemos la página no se recargará, que es lo que queremos. \n \n - if( inputValor.trim().length > 2 ) -> si imputValor sin contar los espacios delante y detrás es mayor que dos...\nsetCategories( catgrs => [...catgrs, inputValor]); -> añadimos al array(estado) de GifExpertApp lo que hemos introducido en el input \n \n - setInputValor(''); -> el estado de inputValor será un string vacío después de pulsar enter\n\n - Con PropTypes.func.isRequired nos aseguramos que cualquiera que utilice nuestro componente con los argumentos que estoy esperando.\n\n*/","\n\nexport const getGifs = async( category ) => {\n\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=12&api_key=iI6W0H5w2YPRicsqy9TqzHuU5pyooo5F`;\n    const resp = await fetch( url ); // nos delvolverá una promise(response)\n    const { data } = await resp.json(); // convierte la resp en un json, esto tambień es una promesa\n\n    // Vamos a recorrer cada uno de los 12 resultados(gifs)\n    const gifs = data.map( img => {\n\n        // Y retornamos un objeto con la información exclusiva que nos interesa.\n        return { \n            id: img.id,\n            title: img.title,\n            url: img.images?.downsized_medium.url\n        }\n\n    });\n    \n    return gifs; \n\n}\n\n\n/* \nNOTAS:\n - Los helpers son funciones que hacen un trabajo específico, pueden recibir argumentos, lo procesan y hacen algún return. \n\n - Hemos quitado esta función asíncrona del componente GifGrid. \n \n - Como getGifs es una función asíncrona no retorna directamente los gifs, si no una promesa que resuelve la colección\n   de imágenes. \n\n*/\n","import React from 'react'\n\n/* SIN DESTRUCTURING:\n\nexport const GifGridItem = ( imag ) => {\n\n    console.log(imag.imag.id)\n    console.log(imag.imag.title)  \n    console.log(imag.imag.url\n\n    return (\n        <div>\n            <img src={ imag.imag.url } alt={ imag.imag.title } />\n            <p> { imag.imag.title } </p>\n        </div>\n    )\n*/\n\n/* CON DESTRUCTURING: */\nexport const GifGridItem = ({ id, title, url }) => {\n    \n    //console.log({ id, title, url });\n\n    return (\n        <div className=\"card animate__animated animate__fadeIn\">\n            <img src={ url } alt={ title } />\n            <p> { title } </p>\n        </div> \n    )\n}\n\n/*\nNOTAS:\n - El console.log(imag) nos muestra cada img del images.map con sus tres elementos.\n - imag debería llamarse props, pero lo voy a quedar así para entender el funcionamiento, es lo que se llamaría, las properties.\n\n*/","import React from 'react'\nimport { useFetchGifs } from '../hooks/useFetchGifs'\n//import { getGifs } from '../helpers/getGifs';\nimport { GifGridItem } from './GifGridItem';\n\nexport const GifGrid = ({ category }) => {\n\n    //const state = useFetchGifs();\n    const { data:images, loading } = useFetchGifs( category );\n\n    //console.log({ data, loading });\n    \n    \n    /*const [images, setImages] = useState([]);\n    \n    useEffect( () => { //Si la category cambia, va a volver a ejecutar este hook\n\n        getGifs( category ) //Retorna una promesa\n            //.then( imgs => setImages( imgs )) \n            .then( setImages ); //también se puede escribir así en este caso la línea de arriba\n    }, [ category ]);*/\n/*\n    const getGifs = async() => {    NOS LLEVAMOS TODO ESTE CODIGO A OTRO ARCHIVO COMO HELPER\n\n        const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=12&api_key=iI6W0H5w2YPRicsqy9TqzHuU5pyooo5F`;\n        const resp = await fetch( url ); // nos delvolverá una promise(response)\n        const { data } = await resp.json(); // convierte la resp en un json, esto tambień es una promesa\n\n        // Vamos a recorrer cada uno de los 12 resultados(gifs)\n        const gifs = data.map( img => {\n\n            // Y retornamos un objeto con la información exclusiva que nos interesa.\n            return { \n                id: img.id,\n                title: img.title,\n                url: img.images?.downsized_medium.url\n            }\n\n        });\n        \n        console.log(gifs);\n        setImages( gifs ); //Ha pasado de ser un array vació(línea 5) a ser gifs( un objeto con tres elementos)\n\n    }\n*/\n    return (\n\n        <>\n            <h3 className=\"card animate__animated animate__fadeIn\"> { category } </h3>\n\n            {/* Si loading está en true, mostramos Cargando... si no, Data cargada */}\n            {/* { loading ? 'Cargando...' : 'Data cargada' } */}\n            { loading && <p className=\"card animate__animated animate__flash\">Cargando...</p>}{/* Esto es igual que lo de arriba pero es la forma corta */}\n\n            <div className=\"card-grid\">\n                \n                {\n                    images.map( img => {\n                        return (\n                            <GifGridItem {...img} key={ img.id } /> //imag={ img } -> para no destructuring\n                                                \n                        )\n                    })\n                }\n           </div>\n        </>   \n    )\n\n}\n\n/*\nNOTAS:\n - El url lo hemos obtenido utilizando postman. \n\n - getGifs es una función asíncrona porque contiene una petición a un servidor(const resp = await fetch( url );) que no sabemos cuánto \n va a tardar en responder. \n\n - Con fetch hacemos la petición(GET por defecto) al servidor y nos devuelve una promise(response).\n\n - Cuando obtenemos el json(data) vemos que nos devuelve 4 elementos, uno de ellos es data, lo que nos interesa. Con ayuda de\n la destruturación la obtenemos directamente {data}.\n\n - En el return de gifs usamos llaves en lugar de paréntesis porque retornamos un objeto.\n\n - url: img.images?.downsized_medium.url -> el signo de interrogación es por si en alguno no tiene la imagen. Le decimos, si tienes\n la imagen utilizada. En ese caso si no la tuviera no nos daría error. Simplemente no la utiliza.\n\n - useEffect nos permite ejecutar cierto código de manera condicional.\n\n - Con useEffect llamando a la función getGifs(), el 2º argumento de useEffect es un arreglo de dependencias, en este caso vacío. \n Al dejarlo vacío conseguimos que no se repita todo el código de getGifs cada vez que cambiamos algo, por ej. si tuviesemos un botón\n incrementador de un valor, cada vez que lo pulsemos hará la petición fetch, pero si lo ponemos dentro de useEffect y con el array\n de 2º argumento vacío evitaremos eso. \n\n    En resumen, que el código de useEffect tal y como está ahí(ha cambiado ya) lo que consigue es que getGifs() sólo se ejecuta cuando el componente\n    es renderizado por primera vez.\n\n - <GifGridItem img={ img }/> va a recibir el parámetro imag que contiene el img del images.map\n\n - Por cada elemento que recorre el images.map(img) retorna un GifGridItem con su contenido correspondiente.\n\n - {...img} -> usamos el operador spread de img como argumento de GifGridItem. De esta forma estoy enviando cada una de las propiedades\n de las imágenes como una propiedad independiente.\n\n - encodeURI() es para que reemplace los espacios por %20, etc.\n\n*/","import { useEffect, useState } from \"react\"\nimport { getGifs } from \"../helpers/getGifs\";\n\n\nexport const useFetchGifs = ( category ) => {\n\n    const [state, setState] = useState({\n\n        data: [],\n        loading: true\n\n    });\n\n    useEffect( () => { //los useEffect no pueden ser async \n\n        getGifs( category ) //esto es una promesa\n            .then( imgs => {\n                 \n                //console.log(imgs)\n                setState({\n                    data: imgs,\n                    loading: false    \n                });        \n            })\n\n    }, [category])\n\n/*    \n    setTimeout(() => {       \n        setState({\n            data: [1,2,3,4,5,6,7],\n            loading: false\n        })\n    }, 3000);\n*/\n    return state; //El state es un objeto con { data[], loading: true }\n\n}\n\n\n\n/*\nNOTAS:\n - Todos los hooks empiezan por 'use...', como useState, useEffect... Cuando hacemos un custom hook no es obligatorio que empiece\n por use, pero es un standard que sí empiece así para que otros programadores sepan que es un hook. \n\n\n*/","import React, { useState } from 'react'\nimport { AddCategory } from './components/AddCategory'\nimport { GifGrid } from './components/GifGrid'\n\nexport const GifExpertApp = () => {\n\n    const [categories, setCategories] = useState(['Pastor Alemán'])\n/*\n    const añadir = () => {\n\n        setCategories([...categories, 'Malinois']);\n        // o también se puede hacer con callback -> setCategories( (cats) => [...cats, 'Malinois'] );\n\n    }\n*/\n\n    return (\n        <>\n            <h2>GifExpertApp</h2>\n            <AddCategory setCategories={ setCategories }/>\n            <hr></hr>\n\n            <ol>\n                {\n                    categories.map( ( category ) => {\n\n                        return (           // El return y parentesis se puede quitar, pero yo me entero mejor así por ahora\n                            <GifGrid \n                            key={ category }\n                            category={ category } \n                            />\n                        )\n                    })\n                }\n            </ol>\n\n        </>\n    )\n}\n\n/*\n\nNOTAS:\n -  En key vamos a colocar el id único del elemento. Sirve para que React sepa cuál es el elemento que está iterando. Si ese key\n cambia o se necesita borrar, hacer renderizaciones o cambiar algo, react se va a basar en base a key.  \n\n - const añadir es una tarea resuelta por mi. Si quisieramos que 'Malinois' estuviese primero en la lista lo pondriamos así:\n    ['Malinois',...categories ]\n\n - setCategories también puede tener un callback en el cual el argumento es el valor del estado anterior -cats- y el \n nuevo estado -[..cats, 'Malinois']- o los valores anteriores más el que yo estoy agregando.\n\n - Si le damos más de una vez al botón añadir, la consola nos marcará el error de que la key se repite, ya que esta\n debe ser única, y aquí le estamos dando el nombre de la categoria que es lo mismo que estamos agregando. Si la agregamos\n más de una vez, hacemos lo mismo con la key. Esto normalmente no suele pasar porque la key es un identificador de una base de \n datos único e irrepetible. \n\n - En esta línea <AddCategory setCategories={ setCategories }/> ,setCategories es un prop\n\n - El categories.map también podria escribirse... -> categories.map( category => <li key={category}> { category } </li>)\npara ahorra código, pero yo me entero mejor por ahora como lo he dejado. Bueno ya se ha reemplazado por <GifGrid />. \n\n*/\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { GifExpertApp } from './GifExpertApp';\n\nimport './index.css';\n\n\nReactDOM.render(\n    <GifExpertApp />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}